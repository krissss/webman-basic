# 核心组件的使用

## 组件概述

项目在 `support/facade` 目录下提供了多种核心组件的门面封装，简化了常用功能的调用。

## 主要组件

### [Auth 认证组件](../vendor/webman-tech/components-monorepo/packages/auth/README.md)

用于处理用户认证相关功能：

```php
use support\facade\Auth;

// 获取当前登录用户
$user = Auth::guard()->getUser();

// 获取当前用户 ID
$result = Auth::guard()->getId()

// 判断当前用户是否登录
$isLogin = Auth::guard()->isGuest();
```

### [Cache 缓存组件](../vendor/webman-tech/laravel-monorepo/src/LaravelCache/README.md)

使用 Laravel 组件

```php
use support\facade\Cache;

// 存储缓存
Cache::set('key', 'value', 3600);

// 获取缓存
$value = Cache::get('key');

// 删除缓存
Cache::delete('key');
```

使用 `cache` 函数的方式

```php
use support\facade\Cache;

// 存储缓存
cache()->set('key', 'value', 3600);

// 获取缓存
$value = cache()->get('key');

// 删除缓存
cache()->delete('key');
```

#### CacheLocker 基于缓存组件的锁组件

用于实现分布式锁功能：

```php
use support\facade\CacheLocker;

// 获取锁，最多等待 10 秒
$lock = CacheLocker::test('lock-key', 10);

if ($lock->get()) {
    // 获得锁，执行业务逻辑
    // ...
    
    // 释放锁
    $lock->release();
}

// 或者使用自动释放锁的方式
$lock->block(10, function () {
    // 在这里执行需要锁保护的代码
    // 函数执行完后自动释放锁
});
```

使用建议：

- 对每个业务单独定义一个锁，定义在 `support\facade\CacheLocker` 进行补充

### [Redis 组件](../vendor/webman-tech/laravel-monorepo/src/LaravelRedis/README.md)

使用 Laravel 组件

```php
use support\facade\Redis;

// 设置值
Redis::set('key', 'value');

// 获取值
$value = Redis::get('key');

// 执行 Redis 命令
Redis::hset('hash_key', 'field', 'value');
```

使用建议：

- 需要使用缓存的地方应该尽可能先使用 Cache 组件，而不是直接使用 Redis 组件

### [Logger 日志组件](../vendor/webman-tech/components-monorepo/packages/logger/README.md)

```php
use support\facade\Logger;

// 记录不同级别日志
Logger::app('这是一条信息日志');
Logger::operateLog('这是一条操作日志');
Logger::app('这是一条错误日志', 'error');
Logger::app('这是一条带 context 的日志', 'info', ['context' => '自定义 context']);
```

使用建议：

- 对每个业务定义特定的 channel，定义在 `support\facade\Logger` 进行补充

### [Storage 文件存储组件](../vendor/webman-tech/laravel-monorepo/src/LaravelFilesystem/README.md)

```php
use support\facade\Storage;

// 保存文件
Storage::put('path/to/file.txt', '文件内容');

// 读取文件
$content = Storage::get('path/to/file.txt');

// 检查文件是否存在
$exists = Storage::exists('path/to/file.txt');
```

#### File 本地文件 Api

用于处理本地文件操作：

```php
use support\facade\File;

// 获取文件 MIME 类型
$mimeType = File::mimeType('/path/to/file.txt');

// 获取文件扩展名
$extension = File::guessExtension('/path/to/file.txt');

// 读取文件内容
$content = File::get('/path/to/file.txt');

// 写入文件内容
File::put('/path/to/file.txt', '文件内容');

// 追加内容到文件
File::append('/path/to/file.txt', '追加的内容');

// 检查文件是否存在
$exists = File::exists('/path/to/file.txt');

// 删除文件
File::delete('/path/to/file.txt');
```

使用建议

- 尽可能使用 `File` 代替原生 php 函数的使用，如：`file_get_contents` 之类的

### [Validator 验证组件](../vendor/webman-tech/laravel-monorepo/src/LaravelValidation/README.md)

使用 Laravel 组件

```php
use support\facade\Validator;

// 验证数据
$validator = Validator::make($data, [
    'name' => 'required|max:255',
    'email' => 'required|email',
]);

if ($validator->fails()) {
    // 处理验证失败
    $errors = $validator->errors();
}
```

使用 `validator` 函数

```php
// 验证数据
$validator = validator($data, [
    'name' => 'required|max:255',
    'email' => 'required|email',
]);

if ($validator->fails()) {
    // 处理验证失败
    $errors = $validator->errors();
}
```

使用建议

- 项目中使用 `validator` 函数，而不是直接使用 `support\facade\Validator`

### Translation 翻译组件

#### [symfony 翻译组件]((https://www.workerman.net/doc/webman/components/translation.html))

```php
use support\facade\Translation;

// 翻译指定的键
$message = Translation::trans('messages.welcome');

// 带参数的翻译
$message = Translation::trans('messages.welcome', ['name' => 'John']);

// 指定语言翻译
$message = Translation::trans('messages.welcome', [], 'en');
```

使用 `trans` 函数

```php
// 翻译指定的键
$message = trans('messages.welcome');

// 带参数的翻译
$message = trans('messages.welcome', ['name' => 'John']);

// 指定语言翻译
$message = trans('messages.welcome', [], 'en');
```

#### [laravel 翻译组件](../vendor/webman-tech/laravel-monorepo/src/LaravelTranslation/README.md)

```php
use support\facade\TranslationLaravel;

// 翻译指定的键
$message = TranslationLaravel::get('messages.welcome');

// 带参数的翻译
$message = TranslationLaravel::get('messages.welcome', ['name' => 'John']);

// 指定语言翻译
$message = TranslationLaravel::get('messages.welcome', [], 'en');
```

使用 `transL` 函数

```php
// 翻译指定的键
$message = transL('messages.welcome');

// 带参数的翻译
$message = transL('messages.welcome', ['name' => 'John']);

// 指定语言翻译
$message = transL('messages.welcome', [], 'en');
```

使用建议：

- 无论是 symfony 翻译组件还是 laravel 翻译组件，翻译的资源文件位置都在 `resources/translations` 目录下

### [Event 事件组件](https://www.workerman.net/doc/webman/components/event.html)

```php
use support\facade\Event;

// 触发事件
Event::dispatch('user.registered', $user);

// 监听事件
Event::on('user.registered', function ($event) {
    // 处理事件
});
```

使用 `event` 函数

```php
// 触发事件
event('user.registered', $user);
```

监听事件的配置在 `config/event.php` 文件中

### Container 容器组件

使用 Laravel Container 组件

```php
use support\facade\Container;

// 解析实例
$repository = Container::get(RepositoryInterface::class);

// 实例化类并注入依赖
$instance = Container::make(SomeClass::class, ['parameter' => 'value']);

// 判断存在
$exist = Container::has(SomeClass::class);
```

使用建议：

- 容器配置在 `config/container.php` 文件中，相关的初始化单例等也都在其中配置

### [Http 网络请求组件](../vendor/webman-tech/laravel-monorepo/src/LaravelHttp/README.md)

使用 Laravel Http 组件

```php
use support\facade\Http;

// 发送 GET 请求
$response = Http::get('https://api.example.com/users');

// 发送 POST 请求
$response = Http::post('https://api.example.com/users', [
    'name' => 'John',
    'email' => 'john@example.com'
]);

// 发送带 headers 的请求
$response = Http::withHeaders([
    'Authorization' => 'Bearer token',
    'Accept' => 'application/json'
])->get('https://api.example.com/users');

// 发送 JSON 请求
$response = Http::asJson()->post('https://api.example.com/users', [
    'name' => 'John'
]);

// 获取响应数据
$data = $response->json();
$statusCode = $response->status();

// 使用预定义的 httpbin 宏
$response = Http::httpbin()->get('/get');
```

使用建议：

- 为了方便后续的 api 管理，应该尽可能使用 `预定义宏` 的方式去使用，参考 `httpbin`，定义在 `upport\facade\Http` 文件中

更多使用方式见：[Laravel Http 网络请求组件]

### [Queue 队列组件](https://www.workerman.net/doc/webman/queue/redis.html)

使用 webman 的 redis-queue

```php
use support\facade\Queue;

// 同步发送消息到队列
Queue::send('queue-name', ['data' => 'value']);

// 异步发送消息到队列
Queue::sendAsync('queue-name', ['data' => 'value']);

// 延迟发送消息
Queue::send('queue-name', ['data' => 'value'], 60); // 延迟60秒

// 分发任务类
Queue::dispatch(YourJobConsumer::class, ['data' => 'value']);

// 异步分发任务类
Queue::dispatchAsync(YourJobConsumer::class, ['data' => 'value']);
```

队列任务需要继承 `app\components\BaseConsumer` 类：

```php
use app\components\BaseConsumer;

class YourJobConsumer extends BaseConsumer
{
    public $queue = 'queue-name';
    
    public function consume(array $data): void
    {
        // 处理队列任务
    }
}
```

## 其他组件

### [自定义进程](https://www.workerman.net/doc/webman/process.html)

在 `config/process.php` 添加启动进程

相关进程类写在 `app/process` 中

### [Console 命令行](../vendor/webman-tech/laravel-monorepo/src/LaravelConsole/README.md)

使用 Laravel artisan 组件

会自动扫描 `app\command` 目录下的命令

提供 `php artisan` 执行一个命令

常用目录介绍：

```bash
# 列出所有命令
php artisan list

# 创建一个 Command
php artisan make:command Test

# 列出所有 route
php artisan route:list
```

## 全局函数

全局函数定义在 `support/functions.php` 中
